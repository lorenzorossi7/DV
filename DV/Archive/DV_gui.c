//=============================================================================
// DV_gui.c
// 
// call-back functions and initialization
//=============================================================================

#include "forms.h"
#include "DV_forms.h"
#include "DV.h"
#include "DV_gui.h"
#include "reg.h"
#include "misc.h"
#include "fncs.h"
#include "send_bbh_xyz.h"
#include "send_accept_sdf.h"
#include "send_gl_canvas.h"
#include "Cliser.h"
#include "func_table.h"
#include <GL/gl.h>
#include <GL/glx.h>

int ret_arg=0;
int auto_refresh=0;
FD_DV_main_window *fd_DV_main_window;
FD_DV_diff_window *fd_DV_diff_window;
FD_DV_func_window *fd_DV_func_window;
FD_DV_gl_canvas_window *fd_DV_gl_canvas_window;
FD_DV_sl_opts_window *fd_DV_sl_opts_window;
FD_DV_capture_window *fd_DV_capture_window;
FD_DV_annotation_window *fd_DV_annotation_window;
FD_DV_dbrowser_window *fd_DV_dbrowser_window;

int db_open=0;
int db_screen_dump=0;
int db_reverse_y=1;

char diff_reg[MAX_NAME_LENGTH]="",diff_mask_reg[MAX_NAME_LENGTH]="",
     diff_wrt[MAX_NAME_LENGTH]="t",diff_new_reg[MAX_NAME_LENGTH]="";

double diff_mask_val=1;
int diff_wrt_ind=1;

#define RB_ACCEPT_SDF 1
#define RB_GL_CANVAS  2
int rb_send_to=RB_GL_CANVAS;

int gl_canvas_open=0;

#define POS_OFF 0
#define POS_TEXT 1
#define POS_CMAP 2
int gl_pos=POS_OFF;

int diff_close_cb(FL_FORM* form, void *data);
int close_cb(FL_FORM* form, void *data);
int func_close_cb(FL_FORM* form, void *data);
int options_close_cb(FL_FORM* form, void *data);
int capture_close_cb(FL_FORM* form, void *data);
int annotation_close_cb(FL_FORM* form, void *data);
int gl_canvas_close_cb(FL_FORM* form, void *data);
int dbrowser_close_cb(FL_FORM* form, void *data);
int gl_canvas_event_handler(FL_OBJECT *obj, Window win, int win_width,
                            int win_height, XEvent *xev, void *data);

void db_new_grid(reg *r,time_str *ts,grid *g);
void refresh_db(void);
void add_to_hist(const char *s, FL_OBJECT *obj);
void load_def_options(void);

//=============================================================================
// starts the GUI
//=============================================================================
void *start_gui(void *arg)
{
   int argc=1,i,r,g,b;
   char *argv[1]={"dummy"};
   char buf[10];

   // some of the following bit of code was generated by fdesign (with "emit main" menu
   // option)
   
   fl_initialize(&argc, argv, 0, 0, 0);
   fd_DV_main_window = create_form_DV_main_window();
   fd_DV_diff_window = create_form_DV_diff_window();
   fd_DV_func_window = create_form_DV_func_window();
   fd_DV_sl_opts_window = create_form_DV_sl_opts_window();
   fd_DV_gl_canvas_window = create_form_DV_gl_canvas_window();
   fd_DV_capture_window = create_form_DV_capture_window();
   fd_DV_annotation_window = create_form_DV_annotation_window();
   fd_DV_dbrowser_window = create_form_DV_dbrowser_window();

   /* fill-in form initialization code */

   /* show the first form */
   fl_set_app_nomainform(1); // to get around raising/lowering bug
   fl_show_form(fd_DV_main_window->DV_main_window,FL_PLACE_CENTERFREE,FL_FULLBORDER,"Data Vault");

   /* register double-clicking in browser window */
   // didn't work well at all -- only registered about 1/3 of the double clicks
//   fl_set_browser_dblclick_callback(fd_DV_main_window->dv_browser,dv_browser_cb,1);
//   fl_set_object_dblclick(fd_DV_main_window->dv_browser,100); 
   /* increase font size (option in fdesign doesn't work) */
   fl_set_browser_fontsize(fd_DV_main_window->dv_browser,12);
   fl_set_browser_fontsize(fd_DV_diff_window->diff_browser,12);
   fl_set_browser_fontsize(fd_DV_diff_window->diff_mask,12);
   fl_set_browser_fontsize(fd_DV_func_window->func_browser,12);
   fl_set_choice_fontsize(fd_DV_diff_window->diff_wrt,12);
   fl_set_browser_fontsize(fd_DV_func_window->func,12);
   fl_set_input(fd_DV_diff_window->diff_mask_val,"1");
   fl_set_input(fd_DV_func_window->func_mask_val,"1");

   //--------------------------------------------------------------------------
   // default grid conversion options
   //--------------------------------------------------------------------------
   fl_set_input(fd_DV_sl_opts_window->scale,"R.1");
   fl_set_input(fd_DV_sl_opts_window->zoom_a,"1");
   fl_set_input(fd_DV_sl_opts_window->zoom_b,"1");
   gc_opts.in_zscale=fl_get_input(fd_DV_sl_opts_window->scale);
   gc_opts.in_cmap_minz=0;
   gc_opts.in_cmap_maxz=0;
   gc_opts.in_zmin_clip=0;
   gc_opts.in_zmax_clip=0;
   gc_opts.concat_grids=CONCAT_TIME;
   gc_opts.sync_t=SYNC_T_INDEX;
   gc_opts.cmap_type=CMAP_LIN;
   gc_opts.in_zscale=fl_get_input(fd_DV_sl_opts_window->scale);
   fl_set_input(fd_DV_sl_opts_window->mask_val,"1");
   gc_opts.mask_val=1;
   fl_set_input(fd_DV_sl_opts_window->mask,"/chr");
   gc_opts.mask=fl_get_input(fd_DV_sl_opts_window->mask);
   gc_opts.coarsen_step=1;
   gc_opts.ignore_ccoords=0;
   gc_opts.use_zoom=0;

   //--------------------------------------------------------------------------
   // default screen capture options
   //--------------------------------------------------------------------------
   fl_set_input(fd_DV_capture_window->first_index,"0");
   fl_set_input(fd_DV_capture_window->format,"scr_save_%i.jpeg");
   fl_set_input(fd_DV_capture_window->dir,"");
   fl_set_input(fd_DV_capture_window->jpeg_qf,"100");

   auto_refresh=1;
   fl_set_menu_item_mode(fd_DV_main_window->view_menu,2,FL_PUP_CHECK | FL_PUP_RADIO);

   fl_set_goodies_font(FL_NORMAL_STYLE,14);

   fl_set_atclose(close_cb,0);
   fl_set_form_atclose(fd_DV_main_window->DV_main_window,close_cb,0);
   fl_set_form_atclose(fd_DV_diff_window->DV_diff_window,diff_close_cb,0);
   fl_set_form_atclose(fd_DV_func_window->DV_func_window,func_close_cb,0);
   fl_set_form_atclose(fd_DV_gl_canvas_window->DV_gl_canvas_window,gl_canvas_close_cb,0);
   fl_set_form_atclose(fd_DV_sl_opts_window->DV_sl_opts_window,options_close_cb,0);
   fl_set_form_atclose(fd_DV_capture_window->DV_capture_window,capture_close_cb,0);
   fl_set_form_atclose(fd_DV_annotation_window->DV_annotation_window,annotation_close_cb,0);
   fl_set_form_atclose(fd_DV_dbrowser_window->DV_dbrowser_window,dbrowser_close_cb,0);

   fl_set_form_minsize(fd_DV_main_window->DV_main_window,600,460);

   //--------------------------------------------------------------------------
   // set up function browser 
   //--------------------------------------------------------------------------
   i=0;
   while(strlen(func_table[i].name)) 
      fl_add_browser_line(fd_DV_func_window->func,func_table[i++].name);

   fl_select_browser_line(fd_DV_func_window->func,1);

   //--------------------------------------------------------------------------
   // setup canvas event handler
   //--------------------------------------------------------------------------
   fl_add_canvas_handler(fd_DV_gl_canvas_window->gl_canvas,ButtonPress,gl_canvas_event_handler,0);
   fl_add_canvas_handler(fd_DV_gl_canvas_window->gl_canvas,ButtonRelease,gl_canvas_event_handler,0);
   fl_add_canvas_handler(fd_DV_gl_canvas_window->gl_canvas,MotionNotify,gl_canvas_event_handler,0);
   fl_add_canvas_handler(fd_DV_gl_canvas_window->gl_canvas,Expose,gl_canvas_event_handler,0);
   fl_add_canvas_handler(fd_DV_gl_canvas_window->gl_canvas,ResizeRequest,gl_canvas_event_handler,0);

   //--------------------------------------------------------------------------
   // annotation defaults, and font setup
   //--------------------------------------------------------------------------
   fl_set_object_lcol(fd_DV_annotation_window->color,3);
   fl_get_icm_color(3,&r,&g,&b);
   for(i=0;i<NUM_FONTS;i++)
      fl_addto_choice(fd_DV_annotation_window->font,xfont_names[i]); 
   for(i=0;i<MAX_OS_TEXTS;i++)
   {
      sprintf(buf,"%i :",i+1);
      fl_addto_choice(fd_DV_annotation_window->edit,buf);
      os_text_list[i].col.r=(double)r/255;
      os_text_list[i].col.g=(double)g/255;
      os_text_list[i].col.b=(double)b/255;
      os_text_list[i].col_ind=3;
      os_text_list[i].pos.x=20;
      os_text_list[i].pos.y=20;
      os_text_list[i].format_str=0;
      os_text_list[i].print_str=0;
   }

   //--------------------------------------------------------------------------
   // data browser defaults
   //--------------------------------------------------------------------------
   fl_set_input(fd_DV_dbrowser_window->data_fs,"%14.8f");
   fl_set_input(fd_DV_dbrowser_window->coord_fs,"%12.6f");

   //--------------------------------------------------------------------------
   // some rend opts defaults
   //--------------------------------------------------------------------------
   rend_opts.use_spec=0;
   rend_opts.shininess=100;
   rend_opts.pt_size_1d=4;
   rend_opts.line_width_1d=2;

   add_to_hist("1.0",fd_DV_gl_canvas_window->gl_zoom_hist);
   add_to_hist("1.5",fd_DV_gl_canvas_window->gl_zoom_hist);
   add_to_hist("0.5",fd_DV_gl_canvas_window->gl_zoom_hist);
   add_to_hist("0.0",fd_DV_gl_canvas_window->gl_theta_hist);
   add_to_hist("40.0",fd_DV_gl_canvas_window->gl_theta_hist);
   add_to_hist("60.0",fd_DV_gl_canvas_window->gl_theta_hist);
   add_to_hist("0.0",fd_DV_gl_canvas_window->gl_phi_hist);
   add_to_hist("-70.0",fd_DV_gl_canvas_window->gl_phi_hist);
   add_to_hist("30.0",fd_DV_gl_canvas_window->gl_phi_hist);
   add_to_hist("-30.0",fd_DV_gl_canvas_window->gl_phi_hist);
   fl_set_input(fd_DV_gl_canvas_window->gl_zoom,"1.5");
   fl_set_input(fd_DV_gl_canvas_window->gl_theta,"40.0");
   fl_set_input(fd_DV_gl_canvas_window->gl_phi,"-70.0");

   set_gl_canvas_defaults();
   load_def_options();
   
   fl_do_forms();

   pthread_exit((void *)&ret_arg);

   return 0;
}

double model_mat_save[16];
int gl_canvas_close_cb(FL_FORM* form, void *data)
{
   glGetDoublev(GL_MODELVIEW_MATRIX,model_mat_save);
   fl_hide_form(form);
   gl_canvas_open=0;
   return 1;
}

void open_gl_canvas(void)
{
   static int first=1;
   FL_OBJECT *obj=fd_DV_gl_canvas_window->gl_canvas;

   fl_show_form(fd_DV_gl_canvas_window->DV_gl_canvas_window,
                FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV local view");
   fl_set_form_minsize(fd_DV_gl_canvas_window->DV_gl_canvas_window,100,100);
   //--------------------------------------------------------------------------
   // as discussed in xforms manual, Ch 21. on canvas objects:
   //--------------------------------------------------------------------------
   fl_remove_selected_xevent(fl_get_canvas_id(fd_DV_gl_canvas_window->gl_canvas),
                             PointerMotionMask|PointerMotionHintMask);
   if (!first)
   {
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();
      glMultMatrixd(model_mat_save);
   }
   else first=0;

   set_gl_render_mode();
   cam_opts.hw_aspect_ratio=(double)obj->h/obj->w;
   refresh_gl_display();
   gl_canvas_open=1;
}

int close_cb(FL_FORM* form, void *data)
{
    printf("... stopping the server and closing the gui\n");
    // The following is not the most elegant method of
    // shutting down the server ...
    stop_dv_service=1;
    if (ser0_connect_DV(getenv("DVHOST"),DV_PORT)<0)
    printf("... ERROR ... cannot connect to DVHOST\n");
    // I'm not sure whether this is the correct way to shut
    // down the GUI from within a callback routine, but here goes...
    fl_hide_form(form);
    pthread_exit((void *)&ret_arg);
    return 1;
}

int diff_close_cb(FL_FORM* form, void *data)
{
   fl_hide_form(form);
   return 1;
}

int func_close_cb(FL_FORM* form, void *data)
{
   fl_hide_form(form);
   return 1;
}

int options_close_cb(FL_FORM* form, void *data)
{
   fl_hide_form(form);
   return 1;
}

int capture_close_cb(FL_FORM* form, void *data)
{
   fl_hide_form(form);
   return 1;
}

int annotation_close_cb(FL_FORM* form, void *data)
{
   fl_hide_form(form);
   return 1;
}

int dbrowser_close_cb(FL_FORM* form, void *data)
{
   fl_hide_form(form);
   db_open=0;
   return 1;
}
//=============================================================================
// builds the browser list(s) from scratch
//=============================================================================
void create_browser_list()
{
   reg *r;
   time_str *ts;
   level *l;
   grid *g;
   int line=0,ti,li,gi,i,topline;
   int diff_line=0,diff_topline,diff_selected=0,mask_selected=0;
   int mask_line=0,mask_topline;
   int func_line=0,func_topline;
   FL_OBJECT *bl=fd_DV_main_window->dv_browser;
   FL_OBJECT *diff_bl=fd_DV_diff_window->diff_browser;
   FL_OBJECT *mask_bl=fd_DV_diff_window->diff_mask;
   FL_OBJECT *func_bl=fd_DV_func_window->func_browser;
   char buffer[MAX_NAME_LENGTH*2];
   s_iter it;

   // this routine can be called from both threads, so lock immediately
   // to prevent simultaneuos xforms calls
   LOCK_REG_LIST;

   fl_freeze_form(bl->form);
   fl_freeze_form(diff_bl->form);
   fl_freeze_form(func_bl->form);
   topline=fl_get_browser_topline(bl);
   diff_topline=fl_get_browser_topline(diff_bl);
   mask_topline=fl_get_browser_topline(mask_bl);
   func_topline=fl_get_browser_topline(func_bl);
   fl_clear_browser(bl);
   fl_clear_browser(diff_bl);
   fl_clear_browser(mask_bl);
   fl_clear_browser(func_bl);

   fl_add_browser_line(mask_bl,"<none>");
   mask_line++;
   if (!strlen(diff_mask_reg) || !strcmp("<none>",diff_mask_reg))
   {
      strcpy(diff_mask_reg,"<none>");
      fl_select_browser_line(mask_bl,mask_line);
      mask_selected=1;
   }

   r=reg_list;
   while(r)
   {
      LOCK_REG(r);
      //----------------------------------------------------------------
      // It is more useful, I think, to display global
      // level information in the dv window, so here we just call
      // init_s_iter to calculate this information for us,stored
      // in the ln field of the level structure. (For historical reasons 
      // we do not use the s_iter in this function)
      //----------------------------------------------------------------
      init_s_iter(&it,r," "); 

      sprintf(buffer,"@b%s",r->name);

      fl_add_browser_line(bl,buffer);
      line++;

      fl_add_browser_line(func_bl,buffer);
      func_line++;

      fl_add_browser_line(diff_bl,buffer);
      diff_line++;
      if (!strcmp(diff_reg,&buffer[2]))
      {
         fl_select_browser_line(diff_bl,diff_line);
         diff_selected=1;
      }

      fl_add_browser_line(mask_bl,buffer);
      mask_line++;
      if (!strcmp(diff_mask_reg,&buffer[2]))
      {
         fl_select_browser_line(mask_bl,mask_line);
         mask_selected=1;
      }

      r->browser_index=line;
      if (r->selected) fl_select_browser_line(bl,line);
      ts=r->ts;
      ti=0;
      while(ts)
      {
         ti++;
         if (r->opened)
         {
            sprintf(buffer,"   t(%i)=%f",ti,ts->time);
            fl_add_browser_line(bl,buffer);
            line++;
            ts->browser_index=line;
            if (ts->selected) fl_select_browser_line(bl,line);
         }
         else
         {
            ts->browser_index=0; 
            ts->opened=0; 
         }
         l=ts->levels;
         li=0;
         while(l)
         {
            li++;
            if (ts->opened)
            {
               sprintf(buffer,"      dx(%i)=%f",l->ln,l->dx);
               fl_add_browser_line(bl,buffer);
               line++;
               l->browser_index=line;
               if (l->selected) fl_select_browser_line(bl,line);
            }
            else
            {
               l->browser_index=0; 
               l->opened=0; 
            }
            g=l->grids;
            gi=0;
            while(g)
            {
               gi++;
               if (l->opened)
               {
                  sprintf(buffer,"         g(%i) shape=%i",gi,g->shape[0]);
                  fl_add_browser_line(bl,buffer);
                  i=1;
                  while(i<g->dim)
                  {
                     sprintf(buffer,"x%i",g->shape[i++]);
                     fl_addto_browser_chars(bl,buffer);
                  }
                  line++;
                  g->browser_index=line;
                  if (g->selected) fl_select_browser_line(bl,line);
               }
               else
               {
                  g->browser_index=0;
               }
               g=g->next;
            }
            l=l->next;
         }
         ts=ts->next;
      }
      FREE_REG(r);
      r=r->next;
   }

   if (topline<=line)
      fl_set_browser_topline(bl,topline);

   if (func_topline<=func_line)
      fl_set_browser_topline(func_bl,func_topline);

   if (diff_topline<=diff_line)
      fl_set_browser_topline(diff_bl,diff_topline);

   if (mask_topline<=mask_line)
      fl_set_browser_topline(mask_bl,mask_topline);

   if (!mask_selected)
   {
      strcpy(diff_mask_reg,"<none>");
      fl_select_browser_line(mask_bl,1);
   }
      
   if (!diff_selected)
   {
      strcpy(diff_reg,"");
   }

   fl_unfreeze_form(bl->form);
   fl_unfreeze_form(diff_bl->form);
   fl_unfreeze_form(func_bl->form);

   FREE_REG_LIST;

   return;
}
 
//=============================================================================
// null call-back for certain objects
//=============================================================================
void null_cb(FL_OBJECT *obj, long obj_arg)
{
   return;
}

//=============================================================================
// save certain options, particularly annotation info, to the specified
// file (more variables will be added as the need arises)
//
/* format:

os_text:pos.x,pos.y,col_ind,font\nformat_str\n
os_cmap:p1.x,p1.y,p2.x,p2.y,bcol.r,bcol.g,bcol.b,bwidth,show_os_cmap
bbox:width,col.r,col.g,col.b


*/ 
//=============================================================================
int save_options(char *file_name)
{
   FILE *stream;
   int i;
   
   if (!(stream=fopen(file_name,"w")))
   {
      printf("save_options: unable to open file %s\n",file_name);
      return 0;
   }

   for (i=0; i<MAX_OS_TEXTS; i++)
   {
      if (os_text_list[i].format_str && strlen(os_text_list[i].format_str))
         fprintf(stream,"os_text:%f,%f,%i,%i\n%s\n",os_text_list[i].pos.x,
                 os_text_list[i].pos.y,os_text_list[i].col_ind,os_text_list[i].font,
                 os_text_list[i].format_str);
   }

   fprintf(stream,"os_cmap:%f,%f,%f,%f,%f,%f,%f,%i,%i\n",os_cmap_p1.x,os_cmap_p1.y,
           os_cmap_p2.x,os_cmap_p2.y,os_cmap_bcol.r,
           os_cmap_bcol.g,os_cmap_bcol.b,os_cmap_bwidth,show_os_cmap);

   fprintf(stream,"bbox:%i,%f,%f,%f\n",rend_opts.bbox_width,
           rend_opts.bbox_color.r,rend_opts.bbox_color.g,
           rend_opts.bbox_color.b);

   fclose(stream);
   return 1;
}

void replace_ann_edit_fs(const char *fs, int i)
{
   char *b;

   if (os_text_list[i].format_str) free(os_text_list[i].format_str);
   os_text_list[i].format_str=0;
   if (!(b=(char *)malloc(sizeof(char)*(strlen(fs)+10))))
   {
      printf("replace_ann_edit_fs: ERROR ... out of memory\n");
      return;
   }
   if (strlen(fs))
   {
      if (   !(os_text_list[i].format_str=(char *)malloc(sizeof(char)*(strlen(fs)+1)))
          || !(b=(char *)malloc(sizeof(char)*(strlen(fs)+10))) )
      {
         printf("replace_ann_edit_fs: ERROR ... out of memory\n");
         free(b);
         return;
      }
      strcpy(os_text_list[i].format_str,fs);
   } else fs=0;

   if(fs) sprintf(b,"%i :%s",i+1,fs); else sprintf(b,"%i :",i+1);
   fl_replace_choice(fd_DV_annotation_window->edit,i+1,b);
   free(b);
}

void load_def_options(void)
{
   FILE *stream;
   char filename[256],*home;

   if (stream=fopen("default_opts.dvo","r"))
   {
      fclose(stream);
      printf("retrieving default options from the current directory...\n");
      if (load_options("default_opts.dvo")) printf("done\n");
   }
   else 
   {
      if (!(home=getenv("HOME")))
      {
         printf("environment variable $HOME not set ... no default options loaded\n");
         return;
      }
      strncpy(filename,home,220);
      strcat(filename,"/.DV/default_opts.dvo");
      if (!(stream=fopen(filename,"r")))
      {
         printf("attemping to create directory $HOME/.DV\n");
         if ((system("mkdir $HOME/.DV"))==-1)
         {
            printf("... failed. no default options loaded\n");
            return;
         }
         printf("copying /usr/local/lib/DV/default_opts.dvo to $HOME/.DV\n");
         if ((system("cp /usr/local/lib/DV/default_opts.dvo $HOME/.DV"))==-1)
         {
            printf("... failed. no default options loaded\n");
            return;
         }
      }
      else fclose(stream);
      printf("retrieving default options from $HOME/.DV ...\n");
      if (load_options(filename)) printf("done\n");
   }
}


int load_options(char *file_name)
{
   FILE *stream;
   char buf[1024];
   float x1,y1,x2,y2,rf,gf,bf;
   int i,r,g,b;
   
   if (!(stream=fopen(file_name,"r")))
   {
      printf("load_options: unable to open file %s\n",file_name);
      return 0;
   }

   i=0;

   while(fgets(buf,1024,stream))
   {
      if (!(strncmp(buf,"os_text:",8)) && i<MAX_OS_TEXTS)
      {
         sscanf(&buf[8],"%f,%f,%i,%i",&x1,&y1,&os_text_list[i].col_ind,&os_text_list[i].font);
         fl_get_icm_color(os_text_list[i].col_ind,&r,&g,&b);
         os_text_list[i].col.r=(double)r/255;
         os_text_list[i].col.g=(double)g/255;
         os_text_list[i].col.b=(double)b/255;
         os_text_list[i].pos.x=x1;
         os_text_list[i].pos.y=y1;
         if (os_text_list[i].print_str) free(os_text_list[i].print_str); 
         os_text_list[i].print_str=0;
         if (!(fgets(buf,1024,stream)))
            buf[0]=0;
         else if (strlen(buf))
            buf[strlen(buf)-1]=0;
         replace_ann_edit_fs(buf,i);
         i++;
      }
      else if (!(strncmp(buf,"os_cmap:",8)))
      {
         sscanf(&buf[8],"%f,%f,%f,%f,%f,%f,%f,%i,%i\n",&x1,&y1,&x2,&y2,
                &rf,&gf,&bf,&os_cmap_bwidth,&show_os_cmap);
         os_cmap_p1.x=x1;
         os_cmap_p1.y=y1;
         os_cmap_p2.x=x2;
         os_cmap_p2.y=y2;
         os_cmap_bcol.r=rf;
         os_cmap_bcol.g=gf;
         os_cmap_bcol.b=bf;
      }
      else if (!(strncmp(buf,"bbox:",5)))
      {
         sscanf(&buf[5],"%i,%f,%f,%f\n",&rend_opts.bbox_width,&rf,&gf,&bf);
         rend_opts.bbox_color.r=rf;
         rend_opts.bbox_color.g=gf;
         rend_opts.bbox_color.b=bf;
      }
   }

   buf[0]=0;
   while(i<MAX_OS_TEXTS)
      replace_ann_edit_fs(buf,i++);

   i=1;
   fl_set_input(fd_DV_annotation_window->format_str,os_text_list[i].format_str);
   fl_set_choice(fd_DV_annotation_window->font,os_text_list[i].font+1);
   fl_set_object_lcol(fd_DV_annotation_window->color,os_text_list[i].col_ind);
   fl_set_icm_color(FL_FREE_COL1,255*os_cmap_bcol.r,255*os_cmap_bcol.g,255*os_cmap_bcol.b);
   fl_set_choice(fd_DV_annotation_window->border_width,os_cmap_bwidth);
   fl_set_object_lcol(fd_DV_annotation_window->border_color,FL_FREE_COL1);
   fclose(stream);
   if (gl_canvas_open) refresh_gl_display();
   return 1;
}
//=============================================================================
// file menu
//=============================================================================
void file_menu_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int item;
   char *file_name;
   char name[MAX_NAME_LENGTH];
   reg *r;
   FILE *stream;

   IFL printf("in file_menu_cb:\n");

   item=fl_get_menu(obj);

   switch(item)
   {
         case 1: case 2:
         IFL printf("item 1/2 (Read SDF from file) selected\n");
         if (file_name=(char *)fl_show_fselector("Select SDF file",0,"*.sdf",0))
         {
            instr_read_sdf(file_name,item-1);
            create_browser_list();
         }
         break;
      case 3:
         IFL printf("item 3 (Write SDF to file) selected\n");
         LOCK_REG_LIST;
         r=reg_list;
         while(r)
         {
            if (r->selected)
            {
               strcpy(name,r->name);
               break;
            }
            r=r->next;
         }
         FREE_REG_LIST;
         if (!r)
         {
            fl_show_messages("Please select the register to save first");
            break;
         }
         if (file_name=(char *)fl_show_fselector("Enter file name",0,"*.sdf",name))
         {
            if (stream=fopen(file_name,"r"))
            {
               fclose(stream);
               if (!(fl_show_question("Overwrite existing file?",0))) break;
            }
            if (!(instr_write_sdf(name,file_name))) fl_show_message("Error saving to file",file_name,0);
         }
         break;
      case 4: 
         if (file_name=(char *)fl_show_fselector("Select option file",0,"*.dvo",0))
            if (!(load_options(file_name))) fl_show_message("Error reading options:",file_name,0);
         break;
      case 5:
         if (file_name=(char *)fl_show_fselector("Enter file name",0,"*.dvo",name))
         {
            if (stream=fopen(file_name,"r"))
            {
               fclose(stream);
               if (!(fl_show_question("Overwrite existing file?",0))) break;
            }
            if (!(save_options(file_name))) fl_show_message("Error saving to file",file_name,0);
         }
         break;
      case 6:
         fl_show_message("The Data Vault","V0.1  Copyright 2000/2001","F. Pretorius & M.W. Choptuik");
         break;
      case 7:
         close_cb(fl_get_app_mainform(),0);
         break;
      default:
         printf("file_menu_cb: ERROR --- unknown menu item %i\n",item);
   }
   return;
}

//=============================================================================
// edit menu
//=============================================================================
#define OPEN_ALL 1
#define OPEN_ALL_TIMES 2
#define OPEN_ALL_LEVELS 3
#define CLOSE_ALL 4
#define CLOSE_ALL_TIMES 5
#define CLOSE_ALL_LEVELS 6
#define SELECT_ALL 7
#define SELECT_ALL_TIMES 8
#define SELECT_ALL_LEVELS 9
#define SELECT_ALL_GRIDS 10
#define DESELECT_ALL 11
#define DESELECT_ALL_TIMES 12
#define DESELECT_ALL_LEVELS 13
#define DESELECT_ALL_GRIDS 14

void edit_menu_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int item,shift,p;
   s_iter it;
   grid *g;
   reg *r;

   IFL printf("in edit_menu_cb:\n");

   shift=fl_keysym_pressed(XK_Shift_L)||fl_keysym_pressed(XK_Shift_R);

   item=fl_get_menu(obj);

   LOCK_REG_LIST;
   r=reg_list;
   while(r)
   {
      LOCK_REG(r);
      g=init_s_iter(&it,r,0);
      while(g)
      {
         p=0;
         switch(item)
         {
            case OPEN_ALL_LEVELS: if (!shift || it.l->selected) { it.l->opened=1; p=1; }
            case OPEN_ALL_TIMES: if (!shift || p || it.ts->selected) { it.ts->opened=1; p=1; }
            case OPEN_ALL: if (!shift || p || r->selected) r->opened=1;
               break;
            case CLOSE_ALL: if (!shift || r->selected) { r->opened=0; p=1; }
            case CLOSE_ALL_TIMES: if (!shift || p || it.ts->selected) { it.ts->opened=0; p=1; }
            case CLOSE_ALL_LEVELS: if (!shift || p || it.l->selected) it.l->opened=0;
               break;
            case SELECT_ALL_GRIDS: if (!shift || it.l->selected) g->selected=1; 
               break;
            case SELECT_ALL_LEVELS: if (!shift || it.ts->selected) it.l->selected=1;
               break;
            case SELECT_ALL_TIMES: if (!shift || r->selected) it.ts->selected=1;
               break;
            case SELECT_ALL: r->selected=1;
               break;
            case DESELECT_ALL_GRIDS: if (!shift || it.l->selected) g->selected=0; 
               break;
            case DESELECT_ALL_LEVELS: if (!shift || it.ts->selected) it.l->selected=0;
               break;
            case DESELECT_ALL_TIMES: if (!shift || r->selected) it.ts->selected=0;
               break;
            case DESELECT_ALL: r->selected=0;
               break;
         }
         g=next_g(&it);
      }
      FREE_REG(r);
      r=r->next;
   }
   FREE_REG_LIST;

   create_browser_list();
}

//=============================================================================
// debug menu
//=============================================================================
void debug_menu_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int item;

   IFL printf("in debug_menu_cb:\n");

   item=fl_get_menu(obj);

   switch(item)
   {
      case 1: 
         IFL printf("item 1 (dump all) selected\n");
         instr_dump_all();
         break;
      case 2: 
         instr_mem_usage();
         break;
      default:
         printf("debug_menu_cb: ERROR --- unknown menu item %i\n",item);
   }
   return;
}

//=============================================================================
// utility function for managing 'history' choice functions.
// the operation at this time is quite simplistic ... if the
// number of objects exceeds 16, then the history is cleared.
//=============================================================================
#define MAX_HIST 16
void add_to_hist(const char *s, FL_OBJECT *obj)
{
   int i,n,found=0;
   char *p;

   n=fl_get_choice_maxitems(obj);
   if (n>MAX_HIST)
   {
      n=1; fl_clear_choice(obj);
      fl_addto_choice(obj,"history");
   }
   for (i=2; i<=n; i++)
   {
      p=(char *)fl_get_choice_item_text(obj,i);
      if (!strcmp(p,s)) found=1;
   }
   if (!found) fl_addto_choice(obj,s);
}

//=============================================================================
// reads grid conversion parameters from input gadgets
//=============================================================================
void set_gc_opts(void)
{
   char buf[256];

   gc_opts.in_zscale=fl_get_input(fd_DV_sl_opts_window->scale);
   gc_opts.in_cmap_minz=fl_get_input(fd_DV_sl_opts_window->cmap_range_minz);
   gc_opts.in_cmap_maxz=fl_get_input(fd_DV_sl_opts_window->cmap_range_maxz);
   gc_opts.givec=fl_get_input(fd_DV_sl_opts_window->givec);

   if ((strlen(gc_opts.in_cmap_minz)+strlen(gc_opts.in_cmap_maxz)) < 250)
   {
      sprintf(buf,"%s,%s",gc_opts.in_cmap_minz,gc_opts.in_cmap_maxz);
      add_to_hist(buf,fd_DV_sl_opts_window->cmap_hist); 
   }

   if (strlen(gc_opts.in_zscale) < 250)
      add_to_hist(gc_opts.in_zscale,fd_DV_sl_opts_window->scale_hist);

   if (strlen(gc_opts.givec) < 250)
      add_to_hist(gc_opts.givec,fd_DV_sl_opts_window->givec_hist);

   gc_opts.mask=(char *)fl_get_input(fd_DV_sl_opts_window->mask);
   gc_opts.mask_val=atof(fl_get_input(fd_DV_sl_opts_window->mask_val));
   gc_opts.in_zmin_clip=(char *)fl_get_input(fd_DV_sl_opts_window->zmin_clip);
   gc_opts.in_zmax_clip=(char *)fl_get_input(fd_DV_sl_opts_window->zmax_clip);
   gc_opts.cmap_type=fl_get_choice(fd_DV_sl_opts_window->cmap_type);

   gc_opts.zoom_a=1/atof(fl_get_input(fd_DV_sl_opts_window->zoom_a));
   gc_opts.zoom_b=1/atof(fl_get_input(fd_DV_sl_opts_window->zoom_b));
}
   
void options_cb(FL_OBJECT *obj, long obj_arg)
{
   fl_show_form(fd_DV_sl_opts_window->DV_sl_opts_window,FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV local view options");
   fl_set_form_minsize(fd_DV_func_window->DV_func_window,200,100);
}

//=============================================================================
// datavault browser
//
// 'single-select' mode when clicked with middle/right mouse button
//
// Currently, clicking with the right mouse button on a time/level/grid 
// also sends the 'closest' selected grid in the hierarchy to accept_sdf. 
//=============================================================================
#define DBL_CLICK_TIME 300
void dv_browser_cb(FL_OBJECT *obj, long arg)
{
   int ltrace=0,ss_mode;
   reg *r,*rb_r,*ls_r;
   time_str *ts,*rb_ts,*ls_ts;
   level *l;
   grid *g,*rb_g=0,*ls_g=0;
   int line,ti,li,gi,i,lline,mbutton,ct,dbl_click;
   long sec,usec;
   FL_OBJECT *bl=fd_DV_main_window->dv_browser;
   static int pt=0,pline=-1;
   s_iter it;
   char *rb_name;

   mbutton=fl_mouse_button();
   if (mbutton==FL_LEFT_MOUSE) ss_mode=0; else ss_mode=1;

   fl_gettime(&sec,&usec);
   lline=abs(fl_get_browser(bl));
   // the following line counteracts the supposed Xforms 'single click bug'
   if (!(fl_isselected_browser_line(bl,lline)) && ss_mode==1) ss_mode=0;
   ct=usec/1000+sec*1000;
   if ((ct-pt)<DBL_CLICK_TIME && pline==lline) dbl_click=1; else dbl_click=0;
   pt=ct;
   pline=lline;

   IFL printf("in dv_browser_cb, arg=%i, lline=%i, dbl_click=%i, ct=%i:\n",arg,lline,dbl_click,ct);

   LOCK_REG_LIST;

   r=reg_list;

   line=0;

   if (ss_mode) fl_freeze_form(bl->form);

   while(r)
   {
      LOCK_REG(r);
      // if (ss_mode) we must also de-select items that are unopened,
      // and those won't get traversed in later loops; so de-select here:
      if (ss_mode) 
      {
         g=init_s_iter(&it,r,0);
         r->selected=0;
         while(g)
         {
            g->selected=0;
            it.ts->selected=0;
            it.l->selected=0;
            g=next_g(&it);
         }
      }
      if ((line=r->browser_index)>0)
      {
         if (!ss_mode) r->selected=fl_isselected_browser_line(bl,line);
         else
         {
            if (line==lline)
            {
               r->selected=1;
               fl_select_browser_line(bl,line);
            }
            else
            {
               r->selected=0;
               fl_deselect_browser_line(bl,line);
            }
         }
         if (r->opened)
         {
            ts=r->ts;
            while(ts)
            {
               if ((line=ts->browser_index)>0)
               {
                  if (!ss_mode) ts->selected=fl_isselected_browser_line(bl,line);
                  else
                  {
                     if (line==lline)
                     {
                        ts->selected=1;
                        fl_select_browser_line(bl,line);
                        if (mbutton==FL_RIGHT_MOUSE) 
                        {
                           rb_r=r; rb_ts=ts; rb_g=ts->levels->grids;
                        }   
                        ls_r=r; ls_ts=ts; ls_g=ts->levels->grids;
                     }
                     else
                     {
                        ts->selected=0;
                        fl_deselect_browser_line(bl,line);
                     }
                  }
                  if (ts->opened)
                  {
                     l=ts->levels;
                     while(l)
                     {
                        if ((line=l->browser_index)>0)
                        {
                           if (!ss_mode) l->selected=fl_isselected_browser_line(bl,line);
                           else
                           {
                              if (line==lline)
                              {
                                 l->selected=1;
                                 fl_select_browser_line(bl,line);
                                 if (mbutton==FL_RIGHT_MOUSE) 
                                 {
                                    rb_r=r; rb_ts=ts; rb_g=l->grids;
                                 }   
                                 ls_r=r; ls_ts=ts; ls_g=l->grids;
                              }
                              else
                              {
                                 l->selected=0;
                                 fl_deselect_browser_line(bl,line);
                              }
                           }
                           if (l->opened)
                           {
                              g=l->grids;
                              while(g)
                              {
                                 if ((line=g->browser_index)>0)
                                 {
                                    if (!ss_mode) g->selected=fl_isselected_browser_line(bl,line);
                                    else
                                    {
                                       if (line==lline)
                                       {
                                          g->selected=1;
                                          fl_select_browser_line(bl,line);
                                          if (mbutton==FL_RIGHT_MOUSE) 
                                          {
                                             rb_r=r; rb_ts=ts; rb_g=g;
                                          }   
                                          ls_r=r; ls_ts=ts; ls_g=g;
                                       }
                                       else
                                       {
                                          g->selected=0;
                                          fl_deselect_browser_line(bl,line);
                                       }
                                    }
                                 }
                                 g=g->next;
                              }
                           }
                           if (dbl_click && l->browser_index==lline)
                              l->opened=(l->opened ? 0 : 1);
                        }
                        l=l->next;
                     }
                  }
                  if (dbl_click && ts->browser_index==lline)
                     ts->opened=(ts->opened ? 0 : 1);
               }
               ts=ts->next;
            }
         }
         if (dbl_click && r->browser_index==lline)
            r->opened=(r->opened ? 0 : 1);
      }
      FREE_REG(r);
      r=r->next;
   }
  
   if (ls_g && db_open) db_new_grid(ls_r,ls_ts,ls_g);
   if (rb_g)
   {
      switch(rb_send_to)
      {
         case RB_ACCEPT_SDF: 
            send_accept_sdf_1g(rb_r->name,rb_ts->time,rb_g);
            break;
         case RB_GL_CANVAS: 
            if (!gl_canvas_open) open_gl_canvas();
            set_gc_opts();
            rb_name=rb_r->name;
            break;
         default:
            break;
      }
   }

   if (ss_mode) fl_unfreeze_form(bl->form);

   FREE_REG_LIST;

   if (rb_g && RB_GL_CANVAS==rb_send_to)
   {
      if (gc_opts.concat_grids!=CONCAT_NONE) send_gl_canvas(1,0,0,0);
      else send_gl_canvas(1,rb_g,rb_name,0);
   }

   if (dbl_click) create_browser_list();

   return;
}

//=============================================================================
// View
//=============================================================================
void view_menu_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int item;
   int mode;

   IFL printf("in options_menu_cb:\n");

   item=fl_get_menu(obj);

   switch(item)
   {
      case 1: 
         IFL printf("item 1 (refresh view) selected\n");
         create_browser_list();
         break;
      case 2: 
         IFL printf("item 2 (auto-refresh) selected\n");
         if (auto_refresh)
         {
            auto_refresh=0;
            mode=FL_PUP_RADIO;
         }
         else
         {
            auto_refresh=1;
            mode=FL_PUP_RADIO | FL_PUP_CHECK;
         }
            
         fl_set_menu_item_mode(obj,2,mode);
         create_browser_list();
         break;
      default:
         printf("options_menu_cb: ERROR --- unknown menu item %i\n",item);
   }
   return;
}

//=============================================================================
// help --- disabled
//=============================================================================
void help_menu_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;

   IFL printf("in help_menu_cb:\n");

   return;
}

//=============================================================================
// delete
//=============================================================================
void delete_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int item;
   int mode;

   IFL printf("in delete_cb:\n");

   item=fl_get_menu(obj);

   switch(item)
   {
      case 1: 
         IFL printf("item 1 (selected and opened) selected\n");
         mode=DM_SELECTED_AND_OPENED;
         break;
      case 2: 
         IFL printf("item 2 (selected) selected\n");
         mode=DM_SELECTED;
         break;
      case 3:
         IFL printf("item 3 (all) selected\n");
         mode=DM_ALL;
         break;
      case 4:
         IFL printf("item 4 (last) selected\n");
         mode=DM_LAST_TIME_OF_SELECTED;
         break;
      default:
         printf("delete_cb: ERROR --- unknown item %i\n",item);
         return;
   }
   
   delete_grids(mode);

   create_browser_list();

   return;
}

//=============================================================================
// functions
//=============================================================================
void functions_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;

   IFL printf("in functions_cb:\n");

   fl_show_form(fd_DV_func_window->DV_func_window,FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV functions");
   fl_set_form_minsize(fd_DV_func_window->DV_func_window,500,400);
}

int get_selected_func()
{
   int i,imax;

   imax=fl_get_browser_maxline(fd_DV_func_window->func);
   for (i=1; i<=imax; i++) if (fl_isselected_browser_line(fd_DV_func_window->func,i)) return i;

   printf("get_selected_func: Error, no function selected!!\n");
   return 1;
}
   
int func_build_name()
{
   int i;
   char buffer[3*MAX_NAME_LENGTH],*a,*b;

   buffer[0]=0;
   i=get_selected_func()-1;

   a=(char *)fl_get_input(fd_DV_func_window->func_reg_a);
   b=(char *)fl_get_input(fd_DV_func_window->func_reg_b);

   if ((func_table[i].func_type==TYPE_BINARY_FUNC ||  
        func_table[i].func_type==TYPE_MERGE ) && a && b)
      sprintf(buffer,func_table[i].new_func_ps,a,b);
   else if ((func_table[i].func_type==TYPE_UNARY_FUNC ||
             func_table[i].func_type==TYPE_RENAME) && a)
      sprintf(buffer,func_table[i].new_func_ps,a);

   buffer[MAX_NAME_LENGTH-1]=0;
   fl_set_input(fd_DV_func_window->func_new_reg,buffer);

   return i;
}

void func_browser_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int mbutton,line;
   char *name;

   IFL printf("in func_browser_cb:\n");

   line=fl_get_browser(obj);
   name=&((char *)fl_get_browser_line(obj,line))[2];

   mbutton=fl_mouse_button();
   if (mbutton==FL_LEFT_MOUSE)
      fl_set_input(fd_DV_func_window->func_reg_a,name);
   else if (mbutton==FL_MIDDLE_MOUSE)
      fl_set_input(fd_DV_func_window->func_reg_b,name);
   else
      fl_set_input(fd_DV_func_window->func_mask,name);

   func_build_name();
}

void func_reg_a_cb(FL_OBJECT *obj, long obj_arg)
{
   func_build_name();
}

void func_reg_b_cb(FL_OBJECT *obj, long obj_arg)
{
   func_build_name();
}

void func_go_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0,ret,i;
   char *t1="__DV_Gui_temporary_register: t1";
   reg *r;
   char *mask,*a,*b,*args,*new_reg,*givec;
   double mask_val;

   IFL printf("in func_go_cb:\n");

   i=get_selected_func()-1;

   if (func_table[i].func_type==TYPE_NULL_FUNC) return;

   args=(char *)fl_get_input(fd_DV_func_window->func_args);
   if (func_table[i].func_type==TYPE_SPECIAL)
   {
      ((SPECIAL_FNC)func_table[i].func)(args);
      create_browser_list();
      return;
   }
   a=(char *)fl_get_input(fd_DV_func_window->func_reg_a);
   b=(char *)fl_get_input(fd_DV_func_window->func_reg_b);
   mask=(char *)fl_get_input(fd_DV_func_window->func_mask);
   mask_val=atof(fl_get_input(fd_DV_func_window->func_mask_val));
   new_reg=(char *)fl_get_input(fd_DV_func_window->func_new_reg);
   givec=(char *)fl_get_input(fd_DV_func_window->givec);

   if (strlen(new_reg)>=MAX_NAME_LENGTH)
   {
      fl_show_messages("New register name is longer than the maximum allowed name");
      return;
   }

   if (!(r=find_reg(a,1,1)))
   {
      fl_show_messages("Register A not found");
      return;
   }
   FREE_REG(r);

   // for effeciency, treat rename separately
   if (func_table[i].func_type==TYPE_RENAME)
   {
      rename_reg(a,new_reg);
      create_browser_list();
      return;
   }

   if (strlen(mask))
   {
      if (!(r=find_reg(mask,1,1)))
      {
         fl_show_messages("Mask register not found");
         return;
      }
      FREE_REG(r);
   }

   if (!fl_get_button(fd_DV_func_window->func_overwrite) && (r=find_reg(new_reg,1,1)))
   {
      FREE_REG(r);
      if (!(fl_show_question("overwrite existing register?",0))) return;
   }

   //--------------------------------------------------------------------------
   // use a temporary register in case the new register is the same as the old
   //--------------------------------------------------------------------------
   delete_reg(t1);
   if (func_table[i].func_type==TYPE_UNARY_FUNC)
   {
      if (!(apply_unary_gf((UNARY_FNC)func_table[i].func,args,a,t1,mask,mask_val,givec)))
      {
         fl_show_messages("apply_unary_gf() failed --- see DV console output");
         delete_reg(t1);
         return;
      }
   }
   else
   {
      if (!(r=find_reg(b,1,1)))
      {
         fl_show_messages("Register B not found");
         return;
      }
      FREE_REG(r);
      if (func_table[i].func_type==TYPE_MERGE)
      {
         if (!(merge_gf(a,b,t1,givec)))
         {
            fl_show_messages("merge_gf() failed --- see DV console output");
            delete_reg(t1);
            return;
         }
      }
      else if (!(apply_binary_gf((BINARY_FNC)func_table[i].func,args,a,b,t1,mask,mask_val,givec)))
      {
         fl_show_messages("apply_binary_gf() failed --- see DV console output");
         delete_reg(t1);
         return;
      }
   }

   delete_reg(new_reg);
   rename_reg(t1,new_reg);
   create_browser_list();
}

void func_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;
   int i;

   IFL printf("in func_cb:\n");

   i=func_build_name();
   fl_set_object_label(fd_DV_func_window->func_info,func_table[i].info);
}

//=============================================================================

//=============================================================================
// differentiate
//=============================================================================
void diff_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;

   IFL printf("in diff_cb:\n");

   fl_show_form(fd_DV_diff_window->DV_diff_window,FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV differentiate");
   fl_set_form_minsize(fd_DV_diff_window->DV_diff_window,700,220);
}

void diff_browser_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0,found_choice=0;
   int line,i;
   char *sel;
   reg *r;
   FL_OBJECT *wrt;
   char *def_coord[4]={"t","x1","x2","x3"};
   char msg[MAX_NAME_LENGTH+30];
   char *name;

   IFL printf("in diff_browser_cb:\n");

   wrt=fd_DV_diff_window->diff_wrt;

   line=fl_get_browser(obj);

   name=(char *)fl_get_browser_line(obj,line);
   strcpy(diff_reg,&name[2]);
   if (!(r=find_reg(diff_reg,1,1)))
   {
      sprintf(msg,"Register %s not found!",diff_reg);
      fl_show_messages(msg);
      return;
   }

   fl_clear_choice(wrt);
   for (i=0;i<MAX_DIM+1;i++)
   {
      if (r->coord_names[i]) name=r->coord_names[i]; else name=def_coord[i];
      fl_addto_choice(wrt,name);
      if (!strcmp(name,diff_wrt))
      {
         found_choice=1;
         fl_set_choice(wrt,i+1);
      }
   }

   if (!found_choice)
   {
      if (r->coord_names[0]) strcpy(diff_wrt,r->coord_names[0]);
      else strcpy(diff_wrt,def_coord[0]);
      fl_set_choice(wrt,1);
   }

   if ((strlen(diff_wrt)+strlen(diff_reg)) < (MAX_NAME_LENGTH-1))
   {
      sprintf(diff_new_reg,"%s_%s",diff_reg,diff_wrt);
      fl_set_input(fd_DV_diff_window->diff_new_reg,diff_new_reg);
   }

   FREE_REG(r);
   return;
}

void diff_mask_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0,line;
   char *name;

   IFL printf("in diff_mask_cb:\n");

   name=(char *)fl_get_browser_line(obj,line=fl_get_browser(obj));
   if (name && line>1) strcpy(diff_mask_reg,&name[2]);
   else strcpy(diff_mask_reg,"<none>");
}

void diff_go_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0,ret,x;
   reg *r;
   char *t1="__DV_Gui_temporary_register: t1";
   char *cmask,*new_reg;

   IFL printf("in diff_go_cb:\n");

   if (!strlen(diff_reg)) return;

   new_reg=(char *)fl_get_input(fd_DV_diff_window->diff_new_reg);
   if (strlen(new_reg)>=MAX_NAME_LENGTH)
   {
      fl_show_messages("New register name is longer than the maximum allowed name");
      return;
   }

   strcpy(diff_new_reg,new_reg);
   if (strlen(diff_new_reg)==0) return;

   diff_mask_val=atof(fl_get_input(fd_DV_diff_window->diff_mask_val));

   if (!fl_get_button(fd_DV_diff_window->diff_overwrite) && (r=find_reg(diff_new_reg,1,1)))
   {
      FREE_REG(r);
      if (!(fl_show_question("overwrite existing register?",0))) return;
   }

   if (strlen(diff_mask_reg)==0 || !strcmp(diff_mask_reg,"<none>"))
      cmask=0;  
   else
      cmask=diff_mask_reg;

   //--------------------------------------------------------------------------
   // use a temporary register in case the new register is the same as the old
   //--------------------------------------------------------------------------
   delete_reg(t1);
   if (diff_wrt_ind==1)
   {
      clone_reg(diff_reg,t1);
      ret=t_diff(t1,cmask,diff_mask_val);
   }
   else
   {
      if (fl_get_choice(fd_DV_diff_window->diff_stencil)==1)
         ret=apply_unary_gf(s_diff,diff_wrt,diff_reg,t1,cmask,diff_mask_val,0);
      else
         ret=apply_unary_gf(s_diff_CN,diff_wrt,diff_reg,t1,cmask,diff_mask_val,0);
   }

   if (!ret)
   {
      delete_reg(t1);
      fl_show_messages("diff() failed --- see DV console output");
   }
   else
   {
      delete_reg(diff_new_reg);
      rename_reg(t1,diff_new_reg);
   }

   create_browser_list();
}

void diff_wrt_cb(FL_OBJECT *obj, long obj_arg)
{
   int ltrace=0;

   IFL printf("in diff_wrt_cb:\n");

   diff_wrt_ind=fl_get_choice(obj);
   strcpy(diff_wrt,fl_get_choice_item_text(obj,diff_wrt_ind));

   if ((strlen(diff_wrt)+strlen(diff_reg)) < (MAX_NAME_LENGTH-1))
   {
      sprintf(diff_new_reg,"%s_%s",diff_reg,diff_wrt);
      fl_set_input(fd_DV_diff_window->diff_new_reg,diff_new_reg);
   }
}

//=============================================================================
// sends selected grids to bbh_xyz
//=============================================================================
void send_to_acceptXYZ_cb(FL_OBJECT *obj, long arg)
{
   int ltrace=0;
   int item;

   IFL printf("in send_to_acceptXYZ_cb:\n");

   // item=fl_get_menu(obj); --- used to be a menu, never used option 1
   item=2; 

   switch(item)
   {
      case 1: 
         IFL printf("item 1 (Selected Grids) selected\n");
         send_bbh_xyz(0);
         break;
      case 2:
         IFL printf("item 2 (Grids of All Selected) selected\n");
         send_bbh_xyz(1);
         break;
      default:
         printf("send_to_acceptXYZ_cb: ERROR --- unknown item %i\n",item);
         return;
   }
   
   return;
}

//=============================================================================
// sends selected grids to AcceptSDF
//=============================================================================
void send_to_acceptSDF_cb(FL_OBJECT *obj, long arg)
{
   int ltrace=0;
   int item;

   IFL printf("in send_to_acceptSDF_cb:\n");

   // item=fl_get_menu(obj); --- used to be a menu, never used option 1
   item=2; 

   switch(item)
   {
      case 1: 
         IFL printf("item 1 (Selected Grids) selected\n");
         send_accept_sdf(0);
         break;
      case 2:
         IFL printf("item 2 (Grids of All Selected) selected\n");
         send_accept_sdf(1);
         break;
      default:
         printf("send_to_acceptSDF_cb: ERROR --- unknown item %i\n",item);
         return;
   }
   
   return;
}

//=============================================================================
// sends selected grids to gl_canvas form
//=============================================================================
void send_to_local_cb(FL_OBJECT *obj, long arg)
{
   int ltrace=0;
   int item;

   IFL printf("in send_to_local_cb:\n");
   
   if (!gl_canvas_open) open_gl_canvas();

   set_gc_opts();

   // item=fl_get_menu(obj); --- used to be a menu, never used option 1
   item=2; 
   
   switch(item)
   {
      case 1: 
         IFL printf("item 1 (Selected Grids) selected\n");
         send_gl_canvas(0,0,0,0);
         break;
      case 2:
         IFL printf("item 2 (Grids of All Selected) selected\n");
         send_gl_canvas(1,0,0,0);
         break;
      default:
         printf("send_to_local_cb: ERROR --- unknown item %i\n",item);
         return;
   }
   
   return;
}

void send_to_explorer_cb(FL_OBJECT *obj, long arg)
{
   return;
}

//=============================================================================
// canvas and related cb's
//=============================================================================
void sl_opts_concat_grids_cb(FL_OBJECT *obj, long arg)
{
   int i;

   i=fl_get_choice(obj);
   switch(i)
   {
      case 1: gc_opts.concat_grids=CONCAT_NONE; break;
      case 2: gc_opts.concat_grids=CONCAT_TIME; break;
      case 3: gc_opts.concat_grids=CONCAT_ALL; break;
   }
}

void sl_opts_sync_cb(FL_OBJECT *obj, long arg)
{
   int i;

   i=fl_get_choice(obj);
   switch(i)
   {
      case 1: gc_opts.sync_t=SYNC_T_INDEX; break;
      case 2: gc_opts.sync_t=SYNC_T_VALUE; break;
   }
}

void sl_opts_amr_cb(FL_OBJECT *obj, long arg)
{
   if (gc_opts.amr) gc_opts.amr=0; else gc_opts.amr=1;
}

void sl_opts_ignore_cb(FL_OBJECT *obj, long arg)
{
   if (gc_opts.ignore_ccoords) gc_opts.ignore_ccoords=0; else gc_opts.ignore_ccoords=1;
}

void sl_opts_zoom_cb(FL_OBJECT *obj, long arg)
{
   if (gc_opts.use_zoom) gc_opts.use_zoom=0; else gc_opts.use_zoom=1;
}

void sl_opts_use_mask_cb(FL_OBJECT *obj, long arg)
{
   if (gc_opts.use_mask) gc_opts.use_mask=0; else gc_opts.use_mask=1;
}

void sl_opts_use_givec_cb(FL_OBJECT *obj, long arg)
{
   if (gc_opts.use_givec) gc_opts.use_givec=0; else gc_opts.use_givec=1;
}

void sl_opts_coarsen_cb(FL_OBJECT *obj, long obj_arg)
{
   gc_opts.coarsen_step=fl_get_choice(obj);
}

void sl_opts_scale_hist_cb(FL_OBJECT *obj, long obj_arg)
{
   if (fl_get_choice(obj)==1) return;
   fl_set_input(fd_DV_sl_opts_window->scale,fl_get_choice_item_text(obj,fl_get_choice(obj)));
   fl_set_choice(obj,1);
}

void sl_opts_cmap_hist_cb(FL_OBJECT *obj, long obj_arg)
{
   char buf[256];
   const char *p,*q;
   int i;

   if (fl_get_choice(obj)==1) return;
   p=q=fl_get_choice_item_text(obj,fl_get_choice(obj));
   i=0;
   while(p && *p && *p!=',') { p++; i++; }
   if (i && i<255)
   {
      strncpy(buf,q,i); buf[i]=0;
      fl_set_input(fd_DV_sl_opts_window->cmap_range_minz,buf);
   }
   else fl_set_input(fd_DV_sl_opts_window->cmap_range_minz,"");

   if (*p) p++; 
   if (*p) fl_set_input(fd_DV_sl_opts_window->cmap_range_maxz,p);
   else fl_set_input(fd_DV_sl_opts_window->cmap_range_maxz,"");

   fl_set_choice(obj,1);
}

void sl_opts_givec_hist_cb(FL_OBJECT *obj, long obj_arg)
{
   if (fl_get_choice(obj)==1) return;
   fl_set_input(fd_DV_sl_opts_window->givec,fl_get_choice_item_text(obj,fl_get_choice(obj)));
   fl_set_choice(obj,1);
}

void show_gl_screen_capture(void)
{
   fl_show_form(fd_DV_capture_window->DV_capture_window,
                FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV screen capture");
   fl_set_form_minsize(fd_DV_capture_window->DV_capture_window,100,100);
}

void show_gl_annotation_cb(void)
{
   fl_show_form(fd_DV_annotation_window->DV_annotation_window,
                FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV annotation");
   fl_set_form_minsize(fd_DV_annotation_window->DV_annotation_window,300,200);
}

void gl_options_menu_cb(FL_OBJECT *obj, long arg)
{
   int i;
   char zoom[128];

   i=fl_get_menu(obj);

   sprintf(zoom,"%f",1/cam_opts.zoom);

   switch(i)
   {
      case 1: rend_opts.render_mode=RENDER_MODE_POINT; break;
      case 2: rend_opts.render_mode=RENDER_MODE_HIDDEN_LINE; break;
      case 3: rend_opts.render_mode=RENDER_MODE_SOLID; rend_opts.smooth=0; break;
      case 4: rend_opts.render_mode=RENDER_MODE_SOLID; rend_opts.smooth=1; break;
      case 6: if (rend_opts.draw_bboxes)
              {
                 rend_opts.draw_bboxes=0; 
                 fl_set_menu_item_mode(obj,6,FL_PUP_RADIO); 
              }
              else
              {
                 rend_opts.draw_bboxes=1; 
                 fl_set_menu_item_mode(obj,6,FL_PUP_RADIO|FL_PUP_CHECK);
              }
              break;
      case 8: show_gl_screen_capture(); break;
      case 9: show_gl_annotation_cb(); break;
      case 11: fl_set_input(fd_DV_sl_opts_window->zoom_a,zoom); break;
      case 12: fl_set_input(fd_DV_sl_opts_window->zoom_b,zoom); break;
   }
   if (i<=4) set_gl_render_mode();
   if (i<=4 || i==6) refresh_gl_display(); 
}

void refresh_os_text(int i)
{
   if (os_text_list[i].print_str) free(os_text_list[i].print_str);
   os_text_list[i].print_str=0;
   refresh_gl_display();
}

void gl_ann_edit_cb(FL_OBJECT *obj, long arg)
{
   int i;

   i=fl_get_choice(obj)-1;
   fl_set_input(fd_DV_annotation_window->format_str,os_text_list[i].format_str);
   fl_set_choice(fd_DV_annotation_window->font,os_text_list[i].font+1);
   fl_set_object_lcol(fd_DV_annotation_window->color,os_text_list[i].col_ind);
}

void gl_ann_font_cb(FL_OBJECT *obj, long arg)
{
   int i,f;

   i=fl_get_choice(fd_DV_annotation_window->edit)-1;
   f=fl_get_choice(fd_DV_annotation_window->font)-1;
   os_text_list[i].font=f;
   refresh_os_text(i);
}

void gl_ann_color_cb(FL_OBJECT *obj, long arg)
{
   int i,r,g,b;

   i=fl_get_choice(fd_DV_annotation_window->edit)-1;
   os_text_list[i].col_ind=fl_show_colormap(os_text_list[i].col_ind);
   fl_get_icm_color(os_text_list[i].col_ind,&r,&g,&b);
   os_text_list[i].col.r=(double)r/255;
   os_text_list[i].col.g=(double)g/255;
   os_text_list[i].col.b=(double)b/255;
   fl_set_object_lcol(obj,os_text_list[i].col_ind);
   refresh_os_text(i);
}

void gl_ann_bbox_color_cb(FL_OBJECT *obj, long arg)
{
   static int i=2,r,g,b;

   i=fl_show_colormap(i);
   fl_get_icm_color(i,&r,&g,&b);
   rend_opts.bbox_color.r=(double)r/255;
   rend_opts.bbox_color.g=(double)g/255;
   rend_opts.bbox_color.b=(double)b/255;
   fl_set_object_lcol(obj,i);
   refresh_gl_display(); 
}

void gl_ann_bbox_width_cb(FL_OBJECT *obj, long arg)
{
   rend_opts.bbox_width=fl_get_choice(obj);
   refresh_gl_display(); 
}

void gl_ann_1d_pt_size_cb(FL_OBJECT *obj, long arg)
{
   rend_opts.pt_size_1d=fl_get_choice(obj);
   refresh_gl_display(); 
}

void gl_ann_1d_line_width_cb(FL_OBJECT *obj, long arg)
{
   rend_opts.line_width_1d=fl_get_choice(obj);
   refresh_gl_display(); 
}

void gl_ann_pos_text_cb(FL_OBJECT *obj, long arg)
{
   if (gl_pos!=POS_TEXT) gl_pos=POS_TEXT; else gl_pos=POS_OFF;
   fl_set_button(fd_DV_annotation_window->pos_cmap,0);

}

void gl_ann_pos_cmap_cb(FL_OBJECT *obj, long arg)
{
   if (gl_pos!=POS_CMAP) gl_pos=POS_CMAP; else gl_pos=POS_OFF;
   fl_set_button(fd_DV_annotation_window->pos_text,0);
}

void gl_ann_disp_cmap_cb(FL_OBJECT *obj, long arg)
{
   if (show_os_cmap) show_os_cmap=0; else show_os_cmap=1;
   refresh_gl_display();
}

void gl_ann_border_width_cb(FL_OBJECT *obj, long arg)
{
   os_cmap_bwidth=fl_get_choice(obj);
   if (show_os_cmap) refresh_gl_display();
}

void gl_ann_border_color_cb(FL_OBJECT *obj, long arg)
{
   int i,r,g,b;

   i=fl_show_colormap(1);
   fl_get_icm_color(i,&r,&g,&b);
   os_cmap_bcol.r=(double)r/255;
   os_cmap_bcol.g=(double)g/255;
   os_cmap_bcol.b=(double)b/255;
   fl_set_object_lcol(obj,i);
   if (show_os_cmap) refresh_gl_display();
}

void gl_ann_format_str_cb(FL_OBJECT *obj, long arg)
{
   int i;
   const char *fs;

   fs=fl_get_input(obj);
   i=fl_get_choice(fd_DV_annotation_window->edit)-1;
   replace_ann_edit_fs(fs,i);
   refresh_os_text(i);
}

void gl_home_1d_cb(FL_OBJECT *obj, long arg)
{
   reset_gl_view(1.9,90.0,0.0); 
   refresh_gl_display();
}

void gl_home_cb(FL_OBJECT *obj, long arg)
{
   const char *zoom_c,*theta_c,*phi_c;
   double zoom,theta,phi;

   zoom_c=fl_get_input(fd_DV_gl_canvas_window->gl_zoom);
   theta_c=fl_get_input(fd_DV_gl_canvas_window->gl_theta);
   phi_c=fl_get_input(fd_DV_gl_canvas_window->gl_phi);

   zoom=atof(zoom_c); if (zoom==0) zoom=1;
   theta=atof(theta_c);
   phi=atof(phi_c);

   add_to_hist(zoom_c,fd_DV_gl_canvas_window->gl_zoom_hist);
   add_to_hist(theta_c,fd_DV_gl_canvas_window->gl_theta_hist);
   add_to_hist(phi_c,fd_DV_gl_canvas_window->gl_phi_hist);

   reset_gl_view(zoom,theta,phi); 
   refresh_gl_display();
}  

void gl_zoom_hist_cb(FL_OBJECT *obj, long obj_arg)
{
   if (fl_get_choice(obj)==1) return;
   fl_set_input(fd_DV_gl_canvas_window->gl_zoom,fl_get_choice_item_text(obj,fl_get_choice(obj)));
   fl_set_choice(obj,1);
}

void gl_theta_hist_cb(FL_OBJECT *obj, long obj_arg)
{
   if (fl_get_choice(obj)==1) return;
   fl_set_input(fd_DV_gl_canvas_window->gl_theta,fl_get_choice_item_text(obj,fl_get_choice(obj)));
   fl_set_choice(obj,1);
}

void gl_phi_hist_cb(FL_OBJECT *obj, long obj_arg)
{
   if (fl_get_choice(obj)==1) return;
   fl_set_input(fd_DV_gl_canvas_window->gl_phi,fl_get_choice_item_text(obj,fl_get_choice(obj)));
   fl_set_choice(obj,1);
}

//=============================================================================
// canvas event handler
//
// emulating explorer's trackball:
//
// left (and default) rotates
// middle or ctr+left moves
// left+middle or crt+middle zooms
//=============================================================================
#define ROTATE 1
#define MOVE 2 
#define ZOOM 3

int gl_canvas_event_handler(FL_OBJECT *obj, Window win, int win_width,
                            int win_height, XEvent *xev, void *data)
{
   int ltrace=0;
   FL_FORM *form=fd_DV_gl_canvas_window->DV_gl_canvas_window;
   static int p_mx,p_my,p_action=0;
   static int p_mb=0;
   int mx,my,vx,vy,i;
   unsigned int keymask;
   vect vm,vf;
   double r_mx,r_my,r_mz,norm,rad;
   int lmb=0,mmb=0,rmb=0,shift_mod=0,ctrl_mod=0,action=0;
   double rspeed=0.3,zspeed=0.01,mspeed=0.005,scale;

   IFL printf("in gl_canvas_event_handler:\n");

   if ((xev->type)==ResizeRequest || (xev->type)==Expose)
   {
      cam_opts.hw_aspect_ratio=(double)obj->h/obj->w;
      IFL printf("aspect ratio=%f\n",cam_opts.hw_aspect_ratio);
      glViewport(0,0,obj->w,obj->h);
      refresh_gl_display();
      return 1;
   }

   fl_get_mouse(&mx,&my,&keymask);

   if (keymask&Button1Mask) lmb=1;
   if (keymask&Button2Mask) mmb=1;
   if (keymask&Button3Mask) rmb=1;

   if (keymask&ShiftMask) shift_mod=1; 
   if (keymask&ControlMask) ctrl_mod=1; 

   action=0;
   if ((lmb && mmb) || (ctrl_mod && mmb)) action=ZOOM;
   else if (mmb || (lmb && ctrl_mod)) action=MOVE;
   else if (mmb || lmb || rmb) action=ROTATE;

   IFL printf("mx=%i,my=%i,lmb=%i,mmb=%i,rmb=%i,shift_mod=%i,ctrl_mod=%i:\n",mx,my,lmb,mmb,rmb,shift_mod,ctrl_mod);

   if (gl_pos==POS_TEXT)
   {
      r_mx=mx-(obj->x+form->x);
      r_my=-my+(obj->h+obj->y+form->y);  // screen y is 'reversed', hence - sign
      i=fl_get_choice(fd_DV_annotation_window->edit)-1;
      os_text_list[i].pos.x=r_mx;
      os_text_list[i].pos.y=r_my;
      refresh_os_text(i);
      return 1;
   }
   else if (gl_pos==POS_CMAP)
   {
      r_mx=mx-(obj->x+form->x);
      r_my=-my+(obj->h+obj->y+form->y);  // screen y is 'reversed', hence - sign
      if (lmb)
      {
         os_cmap_p2.x=(os_cmap_p2.x-os_cmap_p1.x)+r_mx;
         os_cmap_p2.y=(os_cmap_p2.y-os_cmap_p1.y)+r_my;
         os_cmap_p1.x=r_mx;
         os_cmap_p1.y=r_my;
      }
      else if (rmb)
      {
         os_cmap_p2.x=r_mx;
         os_cmap_p2.y=r_my;
      }
      refresh_gl_display();
      return 1;
   }

   cam_opts.rot_angle=0;
   cam_opts.dispx=0;
   cam_opts.dispy=0;

   if (action>0 && p_mb>0)
   {
      vx=mx-p_mx;
      vy=my-p_my;

      scale=max(fabs(cam_opts.bbox_ur.x-cam_opts.bbox_ll.x),fabs(cam_opts.bbox_ur.y-cam_opts.bbox_ll.y));
      scale=max(scale,fabs(gc_opts.zscale*(cam_opts.bbox_ur.z-cam_opts.bbox_ll.z)));

      switch(action)
      {
         case ROTATE:
            if (vx==0 && vy==0) return 1;

            // emulate a trackball -- ball sits at the center of the canvas.
           
            // position of mouse relative to center of trackball:
            r_mx=mx-(obj->w/2+obj->x+form->x);
            r_my=-my+(obj->h/2+obj->y+form->y);  // screen y is 'reversed', hence - sign
            rad=(obj->w+obj->h)/4; // radius of track ball
            if ((r_mx*r_mx+r_my*r_my)>(rad*rad)) r_mz=0; else r_mz=sqrt(rad*rad-(r_mx*r_mx+r_my*r_my));
            norm=sqrt(r_mx*r_mx+r_my*r_my+r_mz*r_mz);
            vm.x=r_mx/norm; vm.y=r_my/norm; vm.z=r_mz/norm;
            // vf -- applied 'force' (a better model may be to apply the force
            // tangent to the sphere)
            vf.z=0;
            norm=sqrt(vx*vx+vy*vy);
            vf.x=vx/norm;
            vf.y=-vy/norm;
            // rotation axis is vf X vm :
            cam_opts.rot_axis.x=vf.y*vm.z-vf.z*vm.y;
            cam_opts.rot_axis.y=-(vf.x*vm.z-vf.z*vm.x);
            cam_opts.rot_axis.z=vf.x*vm.y-vf.y*vm.x;
            cam_opts.rot_angle-=norm*rspeed;
            break;
         case ZOOM:
            cam_opts.zoom*=max(0.0001,(1-vy*zspeed));
            break;
         case MOVE: 
            cam_opts.dispx+=mspeed*vx*scale*cam_opts.zoom;
            cam_opts.dispy-=mspeed*vy*scale*cam_opts.zoom;
            break;
      }

      refresh_gl_display();
   }

   p_mx=mx; p_my=my; p_mb=(lmb||mmb||rmb);
   p_action=action;

   return 1;
}
        
//=============================================================================
// screen capture functions
//=============================================================================

void capture_browse_cb(FL_OBJECT *obj, long arg)
{
   fl_show_fselector("Select directory",0,0,0);
   fl_set_input(obj,fl_get_directory());
}

void capture_cb(FL_OBJECT *obj, long arg)
{
   if (capture_on)
   {
      capture_on=0;
      fl_set_object_label(obj,"Start capture");
   }
   else
   {
      capture_on=1;
      fl_set_object_label(obj,"Stop capture");
      capture_n=atoi(fl_get_input(fd_DV_capture_window->first_index));
      capture_dir=fl_get_input(fd_DV_capture_window->dir);
      capture_file_name_fs=fl_get_input(fd_DV_capture_window->format);
      capture_jpeg_qf=atoi(fl_get_input(fd_DV_capture_window->jpeg_qf));
      if (capture_jpeg_qf>100) capture_jpeg_qf=100;
      if (capture_jpeg_qf<0) capture_jpeg_qf=0;
   }
}

//=============================================================================
// data browser functions
//=============================================================================

int db_i0=0;
int db_j0=0;
grid *db_g=0;

void db_new_grid(reg *r,time_str *ts,grid *g)
{
   char buf[1024];
   double dx;
   char *c1,*c2;
   char def_c1[4]="x1";
   char def_c2[4]="x2";

   c1=r->coord_names[1];
   c2=r->coord_names[2];

   if (!c1) c1=def_c1;
   if (!c2) c2=def_c2;

   dx=(g->coords[1]-g->coords[0])/(g->shape[0]-1);

   db_i0=0;
   db_j0=0;
   fl_set_slider_value(fd_DV_dbrowser_window->h_slider,1.0);
   fl_set_slider_value(fd_DV_dbrowser_window->v_slider,1.0);

   if (g->dim==1)
   {
      sprintf(buf,"register: %s\ncoordinate: %s\nshape: [%i], dx=%f, t=%f\n",
              r->name,c1,g->shape[0],dx,ts->time);
      fl_set_slider_bounds(fd_DV_dbrowser_window->v_slider,1.0,(double)g->shape[0]);
   }
   else if (g->dim==2)
   {
      sprintf(buf,"register: %s\ncoordinates: %s,%s\nshape: [%i,%i], dx=%f, t=%f\n",
              r->name,c1,c2,g->shape[0],g->shape[1],dx,ts->time);
      fl_set_slider_bounds(fd_DV_dbrowser_window->v_slider,1.0,(double)g->shape[1]);
      fl_set_slider_bounds(fd_DV_dbrowser_window->h_slider,1.0,(double)g->shape[0]);
   }
   else
   {
      if(db_g) gfree(db_g); db_g=0;
      sprintf(buf,"3D grids not yet supported");
      refresh_db();
      return;
   }

   fl_set_object_label(fd_DV_dbrowser_window->info,buf);

   if (db_g) gfree(db_g);
   if (!(db_g=galloc(g->dim,g->coord_type,g->shape,g->time,g->coords,g->ccoords,g->data)))
      printf("db_new_grid: error, out of memory\n");

   if (g->coord_type!=COORD_UNIFORM && g->dim==1) 
      printf("db_new_grid: WARNING ... only uniform 2D grids will display correct coordinate info\n");

   refresh_db();

   return;
}

void refresh_db(void)
{
   const char *d_fs,*c_fs;
   int width,nx,ny,n,tbuf_size;
   char buf[256];
   char *tbuf,*p,*nl;
   char spaces[31]="                              ";
   double f;

   FL_Coord tx,ty,tw,th;
   double dx,dy,x0,y0,x,y;

   int ascend,descend,cw,ch,nr,nc,i,j;

   FD_DV_dbrowser_window *fd=fd_DV_dbrowser_window;   

   if (!db_g)
   {
      fl_set_object_label(fd->info,"<no data>");
      fl_set_object_label(fd->data," ");
      fl_set_object_label(fd->i_info," ");
      fl_set_object_label(fd->j_info," ");
      return;
   }

   c_fs=fl_get_input(fd->coord_fs);
   d_fs=fl_get_input(fd->data_fs);

   width=0;

   if (db_g->dim==2)
   {
      nx=db_g->shape[0];
      x0=db_g->coords[0];
      dx=(db_g->coords[1]-db_g->coords[0])/(nx-1);
      ny=db_g->shape[1];
      y0=db_g->coords[2];
      dy=(db_g->coords[3]-db_g->coords[2])/(ny-1);
      if (db_reverse_y)
      {
         y0=y0+(ny-1)*dy;
         dy=-dy;
      }
      if (db_i0 >= db_g->shape[0] || db_i0<0) db_i0=0;
      if (db_j0 >= db_g->shape[1] || db_j0 <0) db_j0=0;
   }
   else
   {
      nx=1;
      x0=0;
      dx=0;
      ny=db_g->shape[0];
      y0=db_g->coords[0];
      dy=(db_g->coords[1]-db_g->coords[0])/(ny-1);
      if (db_j0 >= db_g->shape[0] || db_j0 <0) db_j0=0;
      db_i0=0;
   }

   if (db_reverse_y && db_g->dim==2) f=db_g->data[db_i0+(ny-1-db_j0)*nx]; else f=db_g->data[db_i0+db_j0*nx];
   sprintf(buf,d_fs,f);
   width=max(width,strlen(buf));
   sprintf(buf,c_fs,x0+dx);
   width=max(width,strlen(buf));
   width=width+3;
   width=min(width,30);
//   test[width]=0;
//   fl_set_tabstop(test); I couldn't get tabstops to work
   fl_get_object_geometry(fd->data,&tx,&ty,&tw,&th);
   ch=fl_get_char_height(4,12,&ascend,&descend);
   cw=fl_get_char_width(4,12);
   nr=th/ch+1;
   nc=tw/width/cw+1;

//   printf("nr,nc,th,tw,ch,cw,width:%i,%i,%i,%i,%i,%i,%i\n",nr,nc,th,tw,ch,cw,width);

   tbuf_size=nr*nc*width*4;
   if (!(tbuf=(char *)malloc(tbuf_size)))
   {
      printf("refresh_db: out of memory\n"); return;
   }

   p=tbuf;
   if (db_screen_dump) printf("\n");
   for (j=db_j0; j<(nr+db_j0) && j<ny && ((p-tbuf)<tbuf_size/2); j++)
   {
      if (db_screen_dump)
      {
         printf("i1,j=[%5i,%5i], x1,y=[",db_i0+1,j+1);
         printf(c_fs,db_i0*dx+x0);
         printf(",");
         if (db_g->dim==1 && db_g->coord_type==COORD_CURVILINEAR) 
            printf(c_fs,db_g->coords[j]);
         else
            printf(c_fs,j*dy+y0);
         printf("] : ");
      }
      for (i=db_i0; i<(nc+db_i0) && i<nx && ((p-tbuf)<tbuf_size/2); i++)
      {
         if (db_reverse_y && db_g->dim==2) f=db_g->data[i+(ny-1-j)*nx]; else f=db_g->data[i+j*nx];
         sprintf(p,d_fs,f);
         n=strlen(p); p+=n;
         strncpy(p,spaces,abs(width-n)); 
         p+=abs(width-n); *p=0;
         if (db_screen_dump)
         {
            printf(d_fs,f); printf("\t");
         }

      }
      if (db_screen_dump) printf("\n");
      *p++='\n';
      *p=0;
   }

   fl_set_object_label(fd->data,tbuf);

   p=tbuf;
   for (i=db_i0; i<(nc+db_i0) && i<nx;i++)
   {
      sprintf(p,"%5i",i+1);
      n=strlen(p); p+=n;
      strncpy(p,spaces,abs(width-n));
      p+=abs(width-n); *p=0;
   }
   *p++='\n';
   *p=0;
   for (i=db_i0,x=db_i0*dx+x0; i<(nc+db_i0) && i<nx; i++, x+=dx)
   {
      sprintf(p,c_fs,x);
      n=strlen(p); p+=n;
      strncpy(p,spaces,abs(width-n));
      p+=abs(width-n); *p=0;
   }

   fl_set_object_label(fd->i_info,tbuf);

   p=tbuf;
   for (j=db_j0,y=db_j0*dy+y0; j<(nr+db_j0) && j<ny;j++, y+=dy)
   {
      if (db_g->dim==1 && db_g->coord_type==COORD_CURVILINEAR) y=db_g->coords[j];
      sprintf(p,"%5i  ",j+1);
      p+=strlen(p);
      sprintf(p,c_fs,y);
      p+=strlen(p);
      *p++='\n';
      *p=0;
   }

   fl_set_object_label(fd->j_info,tbuf);

   free(tbuf);

   return;
}

void db_h_slider_cb(FL_OBJECT *obj, long arg)
{
   db_i0=fl_get_slider_value(obj)-1;
   refresh_db();
}

void db_v_slider_cb(FL_OBJECT *obj, long arg)
{
   db_j0=fl_get_slider_value(obj)-1;
   refresh_db();
}

void db_data_fs_cb(FL_OBJECT *obj, long arg)
{
   refresh_db();
}

void db_coord_fs_cb(FL_OBJECT *obj, long arg)
{
   refresh_db();
}

void db_reverse_y_cb(FL_OBJECT *obj, long arg)
{
   if (db_reverse_y==1) db_reverse_y=0; else db_reverse_y=1;
   refresh_db();
}

void db_screen_dump_cb(FL_OBJECT *obj, long arg)
{
   if (db_screen_dump)
      db_screen_dump=0;
   else
   {
      db_screen_dump=1;
      refresh_db();
   }
}
void db_sm_save_cb(FL_OBJECT *obj, long obj_arg)
{
 
   char *file_name;
   FILE *stream;
   float *fdata,*f;
   int size,i;
   double *d;
 
   if (!db_g) return;
 
   if (file_name=(char *)fl_show_fselector("Enter file name",0,"*",0))
   {
      if (stream=fopen(file_name,"r"))
      {
         fclose(stream);
         if (!(fl_show_question("Overwrite existing file?",0))) return;
      }
      if (stream=fopen(file_name,"w"))
      {
         size=db_g->shape[0]*db_g->shape[1];
         if (!(f=fdata=(float *)malloc(size*sizeof(float)))) 
         {
            printf("db_sm_save_cb: out of memory\n"); fclose(stream); return;
         }
         d=db_g->data;
         for (i=0;i<size;i++) *f++=*d++;
         fwrite(db_g->shape,sizeof(int),2,stream);
         fwrite(fdata,sizeof(float),size,stream);
         fclose(stream);
         free(fdata);
      }
   }
   return;
}   

void data_browser_cb(FL_OBJECT *obj, long obj_arg)
{
   fl_show_form(fd_DV_dbrowser_window->DV_dbrowser_window,FL_PLACE_CENTERFREE,FL_FULLBORDER,"DV data browser");
   fl_set_form_minsize(fd_DV_func_window->DV_func_window,300,200);
   db_open=1;

   refresh_db();
}

